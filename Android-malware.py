# malware_detector.py
# Android Malware Detection System with GUI

import os
import sys
import time
import threading
import pandas as pd
import numpy as np
import pickle
from pathlib import Path

# Machine Learning imports
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import joblib

# GUI imports
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog
from tkinter.font import Font

# ADB (Android Debug Bridge) for device connection
import subprocess
import json
import hashlib
import re


class AndroidMalwareDetector:
    """Core ML model for Android malware detection"""

    def __init__(self):
        self.model = None
        self.scaler = StandardScaler()
        self.label_encoder = LabelEncoder()
        self.feature_names = []
        self.is_trained = False

    def train_model(self, csv_path):
        """
        Train the malware detection model using a CSV dataset.

        Assumes:
            - Last column is the target label.
            - Features may contain mixed types; only numeric ones are used.
        """
        print("=== Loading dataset ===")
        df = pd.read_csv(csv_path, low_memory=False)

        # Split features/label (last column as label)
        X_full = df.iloc[:, :-1]
        y = df.iloc[:, -1]

        # Encode target if it's string / categorical
        if y.dtype == "object":
            print("[INFO] Encoding string labels to integers...")
            y = self.label_encoder.fit_transform(y)
        else:
            # optional: keep label_encoder None if numeric labels
            self.label_encoder = None

        # Keep only numeric features
        print("[INFO] Selecting numeric feature columns...")
        X_num = X_full.select_dtypes(include=[np.number])

        dropped_cols = [c for c in X_full.columns if c not in X_num.columns]
        if dropped_cols:
            print("\n[INFO] Dropped non-numeric feature column(s):")
            for col in dropped_cols:
                print(f"  - {col}")

        # Replace inf / -inf with NaN, then fill
        X_num = X_num.replace([np.inf, -np.inf], np.nan)
        if X_num.isnull().sum().sum() > 0:
            print(f"[INFO] Filling {int(X_num.isnull().sum().sum())} NaN values with 0.")
        X_num = X_num.fillna(0.0)

        if X_num.shape[1] == 0:
            raise ValueError(
                "No numeric feature columns found after filtering. "
                "Check your dataset and ensure it has numeric features."
            )

        # Save feature names and matrix
        self.feature_names = X_num.columns.tolist()
        X = X_num.values

        print(f"[INFO] Using {X.shape[1]} numeric features for training.")

        # Train/validation split
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42, stratify=y
        )

        # Scale features
        print("[INFO] Scaling features...")
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)

        # Strong Random Forest
        print("[INFO] Training Random Forest model...")
        rf = RandomForestClassifier(
            n_estimators=400,              # more trees
            max_depth=None,               # let trees grow deep
            min_samples_split=2,
            min_samples_leaf=1,
            max_features="sqrt",          # good default for RF
            class_weight="balanced_subsample",  # handle class imbalance
            n_jobs=-1,
            random_state=42,
        )

        # Optional: cross-validation on the training set
        from sklearn.model_selection import StratifiedKFold, cross_val_score

        cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
        print("[INFO] Running 5-fold cross-validation...")
        cv_scores = cross_val_score(
            rf, X_train_scaled, y_train, cv=cv, n_jobs=-1, scoring="accuracy"
        )
        print(f"[CV] Accuracy per fold: {np.round(cv_scores, 4)}")
        print(f"[CV] Mean accuracy: {cv_scores.mean():.4f} +/- {cv_scores.std():.4f}")

        # Fit on full training set
        rf.fit(X_train_scaled, y_train)
        self.model = rf

        # Evaluate on held-out test set
        y_pred = self.model.predict(X_test_scaled)
        acc = accuracy_score(y_test, y_pred)

        print("\n=== HELD-OUT TEST PERFORMANCE ===")
        print(f"Accuracy: {acc:.4f}")

        print("\nConfusion Matrix:")
        print(confusion_matrix(y_test, y_pred))

        print("\nClassification Report:")
        print(classification_report(y_test, y_pred, digits=4))

        # Optional: show top features
        try:
            importances = self.model.feature_importances_
            indices = np.argsort(importances)[::-1][:20]
            print("\nTop 20 important features:")
            for rank, idx in enumerate(indices, start=1):
                fname = self.feature_names[idx]
                print(f"{rank:02d}. {fname:<30}  importance={importances[idx]:.4f}")
        except Exception:
            pass

        self.is_trained = True
        return acc

    def save_model(self, path="android_malware_model.pkl"):
        """Save trained model"""
        model_data = {
            "model": self.model,
            "scaler": self.scaler,
            "label_encoder": self.label_encoder,
            "feature_names": self.feature_names,
        }
        joblib.dump(model_data, path)
        print(f"Model saved to {path}")

    def load_model(self, path="android_malware_model.pkl"):
        """Load pre-trained model"""
        if os.path.exists(path):
            model_data = joblib.load(path)
            self.model = model_data["model"]
            self.scaler = model_data["scaler"]
            self.label_encoder = model_data["label_encoder"]
            self.feature_names = model_data["feature_names"]
            self.is_trained = True
            print(f"Model loaded from {path}")
            return True
        return False

    def predict(self, features):
        """
        Predict if app is malware.
        `features` must be a list/array with length == len(self.feature_names).
        """
        if not self.is_trained:
            raise Exception("Model not trained or loaded!")

        features_scaled = self.scaler.transform([features])
        prediction = self.model.predict(features_scaled)[0]
        probability = self.model.predict_proba(features_scaled)[0]

        return prediction, probability


class ADBInterface:
    """Interface for Android Debug Bridge operations"""

    # Class-level cached adb command
    _adb_cmd = None

    @classmethod
    def _get_adb_cmd(cls):
        """
        Resolve the adb command:
        1. If already detected, reuse it.
        2. Try 'adb' from PATH.
        3. Try common Windows location: C:\\platform-tools\\adb.exe
        """
        if cls._adb_cmd is not None:
            return cls._adb_cmd

        candidates = ["adb"]
        candidates.append(r"C:\platform-tools\adb.exe")

        for cmd in candidates:
            try:
                result = subprocess.run(
                    [cmd, "version"],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode == 0:
                    cls._adb_cmd = cmd
                    return cmd
            except Exception:
                continue

        cls._adb_cmd = "adb"
        return cls._adb_cmd

    @classmethod
    def check_adb(cls):
        """Check if ADB is installed / reachable"""
        cmd = cls._get_adb_cmd()
        try:
            result = subprocess.run(
                [cmd, "version"], capture_output=True, text=True, timeout=5
            )
            return result.returncode == 0
        except Exception:
            return False

    @classmethod
    def get_connected_devices(cls):
        """Get list of connected Android devices"""
        cmd = cls._get_adb_cmd()
        try:
            result = subprocess.run(
                [cmd, "devices"], capture_output=True, text=True, timeout=5
            )
            lines = result.stdout.strip().split("\n")[1:]
            devices = [
                line.split()[0]
                for line in lines
                if line.strip() and "device" in line
            ]
            return devices
        except Exception:
            return []

    @classmethod
    def get_installed_packages(cls, device_id=None):
        """Get all installed packages on device"""
        base_cmd = [cls._get_adb_cmd()]
        if device_id:
            base_cmd.extend(["-s", device_id])
        base_cmd.extend(["shell", "pm", "list", "packages", "-f"])

        try:
            result = subprocess.run(
                base_cmd, capture_output=True, text=True, timeout=30
            )
            packages = []
            for line in result.stdout.strip().split("\n"):
                if line.startswith("package:"):
                    parts = line.replace("package:", "").split("=")
                    if len(parts) == 2:
                        packages.append(
                            {"path": parts[0], "package": parts[1]}
                        )
            return packages
        except Exception:
            return []

    @classmethod
    def get_app_info(cls, package_name, device_id=None):
        """Get detailed info about an app"""
        base_cmd = [cls._get_adb_cmd()]
        if device_id:
            base_cmd.extend(["-s", device_id])
        base_cmd.extend(["shell", "dumpsys", "package", package_name])

        try:
            result = subprocess.run(
                base_cmd, capture_output=True, text=True, timeout=10
            )
            return result.stdout
        except Exception:
            return ""

    @classmethod
    def uninstall_package(cls, package_name, device_id=None):
        """Uninstall a package from device"""
        base_cmd = [cls._get_adb_cmd()]
        if device_id:
            base_cmd.extend(["-s", device_id])
        base_cmd.extend(["uninstall", package_name])

        try:
            result = subprocess.run(
                base_cmd, capture_output=True, text=True, timeout=30
            )
            return "Success" in result.stdout
        except Exception:
            return False

    @staticmethod
    def extract_apk_features(app_info, package_info):
        """Extract features from app for ML model"""
        features = {}

        features["num_permissions"] = app_info.count("android.permission")
        features["num_activities"] = app_info.count("Activity")
        features["num_services"] = app_info.count("Service")
        features["num_receivers"] = app_info.count("Receiver")
        features["has_internet"] = int("INTERNET" in app_info)
        features["has_sms"] = int(
            "SEND_SMS" in app_info or "READ_SMS" in app_info
        )
        features["has_location"] = int(
            "ACCESS_FINE_LOCATION" in app_info
            or "ACCESS_COARSE_LOCATION" in app_info
        )
        features["has_camera"] = int("CAMERA" in app_info)
        features["has_contacts"] = int("READ_CONTACTS" in app_info)
        features["has_phone"] = int("READ_PHONE_STATE" in app_info)

        dangerous_perms = [
            "READ_CONTACTS",
            "WRITE_CONTACTS",
            "READ_CALENDAR",
            "WRITE_CALENDAR",
            "SEND_SMS",
            "RECEIVE_SMS",
            "READ_SMS",
            "CALL_PHONE",
            "READ_PHONE_STATE",
            "ACCESS_FINE_LOCATION",
            "ACCESS_COARSE_LOCATION",
            "CAMERA",
            "RECORD_AUDIO",
            "READ_EXTERNAL_STORAGE",
            "WRITE_EXTERNAL_STORAGE",
        ]
        features["dangerous_permissions"] = sum(
            1 for perm in dangerous_perms if perm in app_info
        )

        return features


class MalwareScannerGUI:
    """GUI Application for Android Malware Scanner"""

    def __init__(self, root):
        self.root = root
        self.root.title("Android Malware Detection System")
        self.root.geometry("1000x700")
        self.root.configure(bg="#1e1e1e")

        self.detector = AndroidMalwareDetector()
        self.adb = ADBInterface()

        self.scanning = False
        self.scan_results = []
        self.current_device = None

        self.setup_ui()
        self.check_prerequisites()

    def setup_ui(self):
        """Setup the user interface"""
        title_font = Font(family="Helvetica", size=20, weight="bold")
        title = tk.Label(
            self.root,
            text="üîí Android Malware Scanner",
            font=title_font,
            bg="#1e1e1e",
            fg="#00ff00",
        )
        title.pack(pady=20)

        main_frame = tk.Frame(self.root, bg="#1e1e1e")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        left_panel = tk.Frame(
            main_frame,
            bg="#2d2d2d",
            relief=tk.RAISED,
            borderwidth=2,
        )
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, padx=(0, 10), pady=0)

        tk.Label(
            left_panel,
            text="Connected Device:",
            bg="#2d2d2d",
            fg="white",
            font=("Arial", 10, "bold"),
        ).pack(pady=(10, 5))

        self.device_var = tk.StringVar()
        self.device_combo = ttk.Combobox(
            left_panel,
            textvariable=self.device_var,
            state="readonly",
            width=25,
        )
        self.device_combo.pack(pady=5)
        self.device_combo.bind(
            "<<ComboboxSelected>>", self.on_device_selected
        )

        tk.Button(
            left_panel,
            text="üîÑ Refresh Devices",
            command=self.refresh_devices,
            bg="#4a4a4a",
            fg="white",
            relief=tk.FLAT,
            padx=20,
            pady=8,
        ).pack(pady=5)

        self.scan_btn = tk.Button(
            left_panel,
            text="üîç Start Scan",
            command=self.start_scan,
            bg="#007acc",
            fg="white",
            font=("Arial", 12, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=12,
        )
        self.scan_btn.pack(pady=20)

        tk.Label(
            left_panel,
            text="Scan Progress:",
            bg="#2d2d2d",
            fg="white",
            font=("Arial", 10, "bold"),
        ).pack(pady=(10, 5))

        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            left_panel,
            variable=self.progress_var,
            maximum=100,
            length=200,
        )
        self.progress_bar.pack(pady=5)

        self.progress_label = tk.Label(
            left_panel,
            text="0%",
            bg="#2d2d2d",
            fg="white",
            font=("Arial", 10),
        )
        self.progress_label.pack(pady=5)

        stats_frame = tk.LabelFrame(
            left_panel,
            text="Scan Statistics",
            bg="#2d2d2d",
            fg="white",
            font=("Arial", 10, "bold"),
        )
        stats_frame.pack(pady=20, padx=10, fill=tk.BOTH)

        self.stats_labels = {}
        stat_names = ["Total Apps", "Scanned", "Threats Found", "Safe Apps"]
        for stat in stat_names:
            frame = tk.Frame(stats_frame, bg="#2d2d2d")
            frame.pack(fill=tk.X, padx=10, pady=5)
            tk.Label(
                frame,
                text=f"{stat}:",
                bg="#2d2d2d",
                fg="#cccccc",
                anchor="w",
            ).pack(side=tk.LEFT)
            label = tk.Label(
                frame,
                text="0",
                bg="#2d2d2d",
                fg="white",
                font=("Arial", 10, "bold"),
            )
            label.pack(side=tk.RIGHT)
            self.stats_labels[stat] = label

        tk.Label(
            left_panel,
            text="Actions:",
            bg="#2d2d2d",
            fg="white",
            font=("Arial", 10, "bold"),
        ).pack(pady=(10, 5))

        self.remove_selected_btn = tk.Button(
            left_panel,
            text="üóëÔ∏è Remove Selected",
            command=self.remove_selected,
            bg="#d9534f",
            fg="white",
            relief=tk.FLAT,
            padx=15,
            pady=8,
            state=tk.DISABLED,
        )
        self.remove_selected_btn.pack(pady=5)

        self.remove_all_btn = tk.Button(
            left_panel,
            text="‚ö†Ô∏è Remove All Threats",
            command=self.remove_all_threats,
            bg="#d9534f",
            fg="white",
            relief=tk.FLAT,
            padx=15,
            pady=8,
            state=tk.DISABLED,
        )
        self.remove_all_btn.pack(pady=5)

        right_panel = tk.Frame(
            main_frame,
            bg="#2d2d2d",
            relief=tk.RAISED,
            borderwidth=2,
        )
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

        tk.Label(
            right_panel,
            text="Scan Results",
            bg="#2d2d2d",
            fg="white",
            font=("Arial", 12, "bold"),
        ).pack(pady=10)

        tree_frame = tk.Frame(right_panel, bg="#2d2d2d")
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal")

        self.results_tree = ttk.Treeview(
            tree_frame,
            columns=("Package", "Status", "Risk", "Confidence"),
            show="tree headings",
            yscrollcommand=vsb.set,
            xscrollcommand=hsb.set,
        )

        vsb.config(command=self.results_tree.yview)
        hsb.config(command=self.results_tree.xview)

        self.results_tree.heading("#0", text="App Name")
        self.results_tree.heading("Package", text="Package Name")
        self.results_tree.heading("Status", text="Status")
        self.results_tree.heading("Risk", text="Risk Level")
        self.results_tree.heading("Confidence", text="Confidence")

        self.results_tree.column("#0", width=150)
        self.results_tree.column("Package", width=200)
        self.results_tree.column("Status", width=100)
        self.results_tree.column("Risk", width=100)
        self.results_tree.column("Confidence", width=100)

        self.results_tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")

        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)

        self.results_tree.tag_configure(
            "threat", background="#ff4444", foreground="white"
        )
        self.results_tree.tag_configure(
            "safe", background="#44ff44", foreground="black"
        )
        self.results_tree.tag_configure(
            "warning", background="#ffaa44", foreground="black"
        )

        log_frame = tk.LabelFrame(
            right_panel,
            text="Activity Log",
            bg="#2d2d2d",
            fg="white",
            font=("Arial", 10, "bold"),
        )
        log_frame.pack(fill=tk.BOTH, padx=10, pady=(0, 10))

        self.log_text = scrolledtext.ScrolledText(
            log_frame,
            height=8,
            bg="#1a1a1a",
            fg="#00ff00",
            font=("Courier", 9),
        )
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        model_frame = tk.Frame(self.root, bg="#1e1e1e")
        model_frame.pack(fill=tk.X, padx=20, pady=(0, 10))

        tk.Button(
            model_frame,
            text="üìÅ Load Model",
            command=self.load_model,
            bg="#5a5a5a",
            fg="white",
            relief=tk.FLAT,
            padx=15,
            pady=5,
        ).pack(side=tk.LEFT, padx=5)

        tk.Button(
            model_frame,
            text="üìä Train Model",
            command=self.train_model_dialog,
            bg="#5a5a5a",
            fg="white",
            relief=tk.FLAT,
            padx=15,
            pady=5,
        ).pack(side=tk.LEFT, padx=5)

        self.model_status_label = tk.Label(
            model_frame,
            text="Model: Not Loaded",
            bg="#1e1e1e",
            fg="#ff4444",
            font=("Arial", 9),
        )
        self.model_status_label.pack(side=tk.LEFT, padx=20)

    def on_device_selected(self, event=None):
        self.current_device = self.device_var.get()

    def log(self, message):
        timestamp = time.strftime("%H:%M:%S")
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(tk.END)
        self.root.update_idletasks()

    def check_prerequisites(self):
        if not self.adb.check_adb():
            messagebox.showerror(
                "ADB Not Found",
                "Android Debug Bridge (ADB) is not installed or not in PATH.\n\n"
                "If you have platform-tools at C:\\platform-tools, this app will try to use it automatically.\n"
                "Otherwise, please install Android SDK Platform Tools:\n"
                "https://developer.android.com/studio/releases/platform-tools",
            )
            self.log("‚ùå ADB not found!")
        else:
            self.log("‚úì ADB detected")
            self.refresh_devices()

    def refresh_devices(self):
        devices = self.adb.get_connected_devices()
        self.device_combo["values"] = devices

        if devices:
            self.device_combo.current(0)
            self.current_device = devices[0]
            self.log(f"‚úì Found {len(devices)} device(s)")
        else:
            self.current_device = None
            self.log(
                "‚ö†Ô∏è No devices connected. Connect via USB and enable USB debugging."
            )
            messagebox.showwarning(
                "No Devices",
                "No Android devices detected.\n\n"
                "Please:\n"
                "1. Connect device via USB\n"
                "2. Enable USB Debugging in Developer Options\n"
                "3. Accept USB debugging prompt on device",
            )

    def load_model(self):
        file_path = filedialog.askopenfilename(
            title="Select Model File",
            filetypes=[("Pickle files", "*.pkl"), ("All files", "*.*")],
        )

        if file_path:
            if self.detector.load_model(file_path):
                self.model_status_label.config(
                    text="Model: Loaded ‚úì", fg="#44ff44"
                )
                self.log("‚úì Model loaded successfully")
                messagebox.showinfo("Success", "Model loaded successfully!")
            else:
                messagebox.showerror("Error", "Failed to load model")

    def train_model_dialog(self):
        file_path = filedialog.askopenfilename(
            title="Select Training Dataset (CSV)",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
        )

        if file_path:
            self.log("Training model... This may take a few minutes.")

            def train_thread():
                try:
                    accuracy = self.detector.train_model(file_path)

                    save_path = filedialog.asksaveasfilename(
                        title="Save Trained Model",
                        defaultextension=".pkl",
                        filetypes=[("Pickle files", "*.pkl")],
                    )

                    if save_path:
                        self.detector.save_model(save_path)
                        self.root.after(
                            0,
                            lambda: self.model_status_label.config(
                                text="Model: Trained ‚úì", fg="#44ff44"
                            ),
                        )
                        self.root.after(
                            0,
                            lambda: self.log(
                                f"‚úì Model trained with {accuracy:.2%} accuracy"
                            ),
                        )
                        self.root.after(
                            0,
                            lambda: messagebox.showinfo(
                                "Success",
                                f"Model trained successfully!\nAccuracy: {accuracy:.2%}",
                            ),
                        )
                except Exception as e:
                    self.root.after(
                        0,
                        lambda: self.log(
                            f"‚ùå Training failed: {str(e)}"
                        ),
                    )
                    self.root.after(
                        0,
                        lambda: messagebox.showerror(
                            "Error", f"Training failed:\n{str(e)}"
                        ),
                    )

            threading.Thread(target=train_thread, daemon=True).start()

    def start_scan(self):
        if not self.detector.is_trained:
            messagebox.showerror(
                "Model Not Loaded", "Please load or train a model first!"
            )
            return

        if not self.current_device:
            messagebox.showerror(
                "No Device", "Please connect a device first!"
            )
            return

        if self.scanning:
            messagebox.showwarning(
                "Scan in Progress", "A scan is already running!"
            )
            return

        self.scanning = True
        self.scan_btn.config(state=tk.DISABLED, text="‚è≥ Scanning...")
        self.remove_selected_btn.config(state=tk.DISABLED)
        self.remove_all_btn.config(state=tk.DISABLED)

        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.scan_results = []

        threading.Thread(target=self.scan_device, daemon=True).start()

    def scan_device(self):
        try:
            self.log(f"üîç Starting scan on device: {self.current_device}")

            packages = self.adb.get_installed_packages(self.current_device)
            total_packages = len(packages)

            self.log(f"Found {total_packages} installed apps")

            self.root.after(
                0,
                lambda: self.stats_labels["Total Apps"].config(
                    text=str(total_packages)
                ),
            )

            threats_found = 0
            safe_apps = 0

            for idx, pkg_info in enumerate(packages):
                if not self.scanning:
                    break

                package_name = pkg_info["package"]
                app_name = package_name.split(".")[-1]

                progress = ((idx + 1) / total_packages) * 100 if total_packages else 0
                self.root.after(
                    0, lambda p=progress: self.progress_var.set(p)
                )
                self.root.after(
                    0,
                    lambda p=progress: self.progress_label.config(
                        text=f"{p:.1f}%"
                    ),
                )
                self.root.after(
                    0,
                    lambda i=idx
                    + 1: self.stats_labels["Scanned"].config(text=str(i)),
                )

                self.log(f"Scanning: {package_name}")

                app_info = self.adb.get_app_info(
                    package_name, self.current_device
                )

                features = self.adb.extract_apk_features(app_info, pkg_info)

                try:
                    feature_vector = [
                        float(features.get(name, 0.0))
                        for name in self.detector.feature_names
                    ]

                    prediction, probability = self.detector.predict(
                        feature_vector
                    )

                    is_malware = prediction == 1
                    confidence = (
                        probability[1] if is_malware else probability[0]
                    )

                    if is_malware:
                        status = "THREAT"
                        risk = "HIGH" if confidence > 0.8 else "MEDIUM"
                        tag = "threat"
                        threats_found += 1
                    else:
                        status = "SAFE"
                        risk = "LOW"
                        tag = "safe"
                        safe_apps += 1

                    result = {
                        "app_name": app_name,
                        "package": package_name,
                        "status": status,
                        "risk": risk,
                        "confidence": f"{confidence:.1%}",
                        "is_malware": is_malware,
                    }
                    self.scan_results.append(result)

                    self.root.after(
                        0,
                        lambda r=result, t=tag: self.results_tree.insert(
                            "",
                            "end",
                            text=r["app_name"],
                            values=(
                                r["package"],
                                r["status"],
                                r["risk"],
                                r["confidence"],
                            ),
                            tags=(t,),
                        ),
                    )

                    self.root.after(
                        0,
                        lambda t=threats_found: self.stats_labels[
                            "Threats Found"
                        ].config(text=str(t)),
                    )
                    self.root.after(
                        0,
                        lambda s=safe_apps: self.stats_labels[
                            "Safe Apps"
                        ].config(text=str(s)),
                    )

                except Exception as e:
                    self.log(f"‚ö†Ô∏è Error analyzing {package_name}: {str(e)}")
                    continue

                time.sleep(0.1)

            self.log(
                f"‚úì Scan complete! Found {threats_found} potential threats"
            )

            if threats_found > 0:
                self.root.after(
                    0,
                    lambda: self.remove_selected_btn.config(
                        state=tk.NORMAL
                    ),
                )
                self.root.after(
                    0,
                    lambda: self.remove_all_btn.config(state=tk.NORMAL),
                )
                self.root.after(
                    0,
                    lambda: messagebox.showwarning(
                        "Threats Detected",
                        f"Found {threats_found} potential malware apps!\n\n"
                        f"Review the results and remove suspicious apps.",
                    ),
                )
            else:
                self.root.after(
                    0,
                    lambda: messagebox.showinfo(
                        "Scan Complete",
                        "No threats detected! Your device appears to be safe.",
                    ),
                )

        except Exception as e:
            self.log(f"‚ùå Scan error: {str(e)}")
            self.root.after(
                0,
                lambda: messagebox.showerror(
                    "Scan Error", f"Error during scan:\n{str(e)}"
                ),
            )

        finally:
            self.scanning = False
            self.root.after(
                0,
                lambda: self.scan_btn.config(
                    state=tk.NORMAL, text="üîç Start Scan"
                ),
            )

    def remove_selected(self):
        selected = self.results_tree.selection()
        if not selected:
            messagebox.showwarning(
                "No Selection", "Please select apps to remove"
            )
            return

        packages_to_remove = []
        for item in selected:
            values = self.results_tree.item(item)["values"]
            if values[1] == "THREAT":
                packages_to_remove.append(values[0])

        if not packages_to_remove:
            messagebox.showinfo("No Threats", "No threat apps selected")
            return

        confirm = messagebox.askyesno(
            "Confirm Removal",
            f"Remove {len(packages_to_remove)} app(s)?\n\n"
            "This action cannot be undone!",
        )

        if confirm:
            self.remove_packages(packages_to_remove)

    def remove_all_threats(self):
        threats = [r for r in self.scan_results if r["is_malware"]]

        if not threats:
            messagebox.showinfo("No Threats", "No threats to remove")
            return

        confirm = messagebox.askyesno(
            "Confirm Removal",
            f"Remove ALL {len(threats)} threat(s)?\n\n"
            "This action cannot be undone!",
        )
        if confirm:
            packages_to_remove = [t["package"] for t in threats]
            self.remove_packages(packages_to_remove)

    def remove_packages(self, packages):
        self.log(f"Removing {len(packages)} package(s)...")

        def remove_thread():
            success_count = 0
            fail_count = 0

            for package in packages:
                self.root.after(
                    0, lambda p=package: self.log(f"Removing: {p}")
                )

                if self.adb.uninstall_package(
                    package, self.current_device
                ):
                    success_count += 1
                    self.root.after(
                        0,
                        lambda p=package: self.log(f"‚úì Removed: {p}"),
                    )

                    for item in self.results_tree.get_children():
                        if (
                            self.results_tree.item(item)["values"][0]
                            == package
                        ):
                            self.root.after(
                                0,
                                lambda i=item: self.results_tree.delete(
                                    i
                                ),
                            )
                            break
                else:
                    fail_count += 1
                    self.root.after(
                        0,
                        lambda p=package: self.log(
                            f"‚ùå Failed to remove: {p}"
                        ),
                    )

            self.root.after(
                0,
                lambda: messagebox.showinfo(
                    "Removal Complete",
                    f"Successfully removed: {success_count}\n"
                    f"Failed: {fail_count}",
                ),
            )

            threats_found = int(
                self.stats_labels["Threats Found"].cget("text")
            )
            self.root.after(
                0,
                lambda: self.stats_labels["Threats Found"].config(
                    text=str(threats_found - success_count)
                ),
            )

        threading.Thread(target=remove_thread, daemon=True).start()


def main():
    root = tk.Tk()
    app = MalwareScannerGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
